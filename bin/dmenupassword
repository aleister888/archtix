#!/bin/bash

# Script para navegar bases de datos de keepassxc con dmenu
# Créditos: https://github.com/neelkamal0310/keepassxc-dmenu/blob/main/keepmenu

# Antes de ejecutar este script asegúrate de tener:
# - Una base de datos almacenada en tu directorio home.
# - Un archivo de texto con la contraseña encriptada de la base de datos (usando gpg).
#   - Genera tu clave gpg usando: gpg --full-gen-key
#   - Crea un archivo de texto plano con la contraseña.
#   - Encripta el archivo con: gpg -e -r ID_CLAVE ARCHIVO_TXT
#     - Para encontrar el ID de tu clave utiliza: gpg --list-secret-keys
#   - Finalmente, elimina de forma segura el archivo original con: shred ARCHIVO_TXT

# Puedes guardar esta clave para usarla en el futuro:
# - Lista todas tus claves públicas disponibles: gpg --list-keys
#   - Guarda la clave pública deseada en un archivo .asc: gpg --export -a KEY_ID > key.asc
#   - Puedes importarla de nuevo con: gpg --import key.asc
# - Lista todas tus claves secretas: gpg --list-secret-keys
#   - Guarda la clave secreta deseada en un archivo: gpg --export-secret-keys KEY_ID > clave_secreta.gpg

# Crearemos una caché donde guardar la última base de datos y clave usadas

dunstctl close-all

cache="$HOME/.cache/dmenupassword"

# Función para regenerar la caché
regenerate_cache() {
	echo "Generando cache... "
	kdbx_files=$(find "$HOME" -name "*.kdbx" 2>/dev/null)
	[ -z "$kdbx_files" ] && notify-send -i keepassxc "No se encontró ninguna base de datos" && exit
	gpg_files=$(find "$HOME" -path "$HOME/.local/share/gnupg" -prune -o -name "*.gpg" -print 2>/dev/null)
	[ -z "$gpg_files" ] && notify-send -i GPG-Key4 "No se encontró ninguna contraseña" && exit
	tempfile=$(mktemp)
	echo "$kdbx_files" | dmenu -p " " | tee "$tempfile" >/dev/null
	echo "$gpg_files" | dmenu -p " " | tee -a "$tempfile" >/dev/null
	mv "$tempfile" "$cache"
}

# Si la caché no existe o tiene más de 5 minutos, regenerarla
if [ ! -f "$cache" ] || [ $(( ( $(date +%s) - $(stat -c %Y "$cache") ) / 60 )) -gt 5 ]; then
	regenerate_cache
else
	echo "Cache encontrada! "
fi

# Localización de la base de datos y la clave
database=$(head -1 "$cache"); passgpg=$(tail -1 "$cache")
# Prompt para la búsqueda
search_prompt="Búsqueda  "
# Comando para dmenu
dmenu="dmenu -l 20"
# Tiempo que se espera para borrar las contraseñas del portapapeles
timeout=10
# Desbloquear la base si no lo esta
gpg -d "$passgpg" 2>/dev/null || \
$TERMINAL $TERMTITLE "scratchpad" $TERMEXEC gpg -d "$passgpg"
# Contraseña desencriptada
pass=$(gpg -d "$passgpg" 2>/dev/null)
# Entradas extraídas de la base de contraseñas
entry=$(echo "$pass" | keepassxc-cli ls "$database" 2>/dev/null)

# Si el comando no lista nada, borrar la caché
if [ -z "$entry" ]; then
	notify-send -i GPG-Key4 "Clave no válida"
	echo "La clave proporcionada no es válida "
	rm "$cache"
	exit 1
fi

# Salir del script si hay entradas duplicadas (keepassxc-cli no puede diferenciarlas)
dup=$(echo "$pass" | keepassxc-cli search "$database" '' 2>/dev/null | sort | uniq -d)
if [ -n "$dup" ]; then
	notify-send "Hay entradas con el mismo nombre"
	echo "$dup" > "$(mktemp "/tmp/dmenupassword.XXXX")"
	exit
else
	rm /tmp/dmenupassword.* 2>/dev/null
fi

# Seleccionar entrada con dmenu
entry=$(printf "%s\n%s" "$search_prompt" "$entry" | eval "$dmenu")

if [ "$entry" = "$search_prompt" ]; then
	# Elegimos buscar las entradas
	search=$(true | dmenu -p "$search_prompt") # Introducir término de búsqueda en dmenu
	entry=$(echo "$pass" | keepassxc-cli search "$database" "$search" | eval "$dmenu") # Seleccionar resultado
	[[ -z "$entry" ]] && exit 1 # Salir si no se selecciona nada
	details=$(echo "$pass" | keepassxc-cli show "$database" "$entry" 2>/dev/null | eval "$dmenu") # Mostrar detalles
else
	# Comprobar si la entrada es un grupo
	while : ; do
		if [[ ! "$entry" =~ .*/ ]]; then
			# Si no es un directorio, mostrar detalles
			[[ -z "$entry" ]] && exit 1 # Salir si no se selecciona nada
			details=$(echo "$pass" | keepassxc-cli show "$database" "$entry" 2>/dev/null | eval "$dmenu")
			break
		else
			# Si es un directorio, seguir eligiendo hasta encontrar una entrada que no lo sea
			gentry=$(echo "$pass" | keepassxc-cli ls "$database" "$entry" 2>/dev/null | eval "$dmenu")
			[[ -z "$gentry" ]] && exit 1 # Salir si no se selecciona nada
			if [[ "$gentry" =~ .*/ ]]; then
				entry="${entry}${gentry}"
			else
				# Si la entrada seleccionada no es un directorio, mostrar detalles
				details=$(echo "$pass" | keepassxc-cli show "$database" "${entry}${gentry}" 2>/dev/null | eval "$dmenu")
				break
			fi
		fi
	done
fi

# Salir si no se selecciona nada
[[ $details ]] || exit

# Determinar qué campo de la entrada se ha seleccionado (Título, usuario, contraseña, etc.)
field=$(echo "$details" | cut -d ':' -f 1)

# Copiar al portapapeles o limpiarlo según el campo seleccionado
if [[ "$field" == "Password" ]]; then
	notify-send "Contraseña copiada ${timeout}s"
	if [[ "$entry" =~ .*/ ]]; then
		echo "$pass" | keepassxc-cli clip "$database" "${entry}${gentry}" >/dev/null
	else
		echo "$pass" | keepassxc-cli clip "$database" "$entry" >/dev/null
	fi
	notify-send -i keepassxc "Se ha limpiado el portapapeles"
else
	echo "$details" | awk -F':' '{sub(/^[ \t]+/, "", $2); printf "%s", $2}' | xclip -sel clip
	notify-send "${field} copiado al portapapeles"
fi
