% arara: xelatex

\documentclass[11pt]{article}
\synctex=1

\usepackage{listings}
\usepackage{graphicx}
\usepackage{multicol}
\setlength{\columnsep}{12.5pt}
\usepackage{caption}
\usepackage{floatrow}
\usepackage{cprotect}
\usepackage{enumitem}

\usepackage{calc}
\usepackage{array,booktabs}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Márgenes y espaciado
\usepackage[
	a4paper, % Tamaño del papel
	top=2.5cm, % Márgen superior
	bottom=2cm, % Márgen inferior
	left=2.25cm, % Márgen izquierdo
	right=2.25cm, % Márgen derecho
	footskip=1cm, % Space from the bottom margin to the baseline of the footer
	headsep=0.5cm, % Space from the top margin to the baseline of the header
	headheight=1cm, % Height of the header
	%showframe
]{geometry}

\usepackage{fontspec} % Required for specifying custom fonts under XeLaTeX

\setmainfont[
Path = /usr/share/fonts/TTF/,
ItalicFont = DejaVuSerif-Italic.ttf,
BoldFont = RobotoCondensed-Bold.ttf,
BoldItalicFont = RobotoCondensed-BoldItalic.ttf
]{DejaVuMathTeXGyre.ttf}

\setmonofont{Iosevka Fixed SS05}

\usepackage[spanish]{babel} % Idioma del documento: Español

\usepackage[nobottomtitles*]{titlesec}
\titlespacing*{\section}{0pt}{7.5pt}{8pt} % Spacing around section titles, the order is: left, before and after

% Colores
\usepackage{xcolor}
\definecolor{mycolor}{HTML}{3CB5D6}

% Encabezado y pie de página
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{\leftmark}
\rhead{{\bfseries\thepage}}
\renewcommand{\headrulewidth}{2pt}
\renewcommand{\footrulewidth}{0pt}

% Notas de colores
\usepackage{tcolorbox}
\tcbuselibrary{skins}
\newtcolorbox{mybox}[1]{
width=\textwidth,
colback=mycolor!10,
colbacktitle=mycolor,
boxrule=-0.1pt,
center,
fonttitle=\bfseries,
title={\hspace*{-8pt}#1}, % Sin indentación en el título
sharp corners
}

% Enlaces clicables
\usepackage[colorlinks=true, linkcolor=mycolor, urlcolor=mycolor]{hyperref}

\begin{document}

\pagestyle{empty}
\vspace*{.3\textheight}
{\hfill\Huge\itshape\textcolor{mycolor}{\textbf{Artix Linux}}\par}

{\hfill\Large Guía de Usuario\par}

\clearpage

\section{Compartir audio}

Al iniciar sesión se crea un \emph{micrófono virtual} con el que podemos combinar el audio de nuestro micrófono con el audio de las aplicaciones. De esta forma podemos compartir junto con nuestra pantalla, el audio de dicha retransmisión en aplicaciones que no tienen dicha funcionalidad.

\medskip
\noindent Para esto tendremos que elegir \textit{my-virtualmic} como nuestro micrófono predeterminado. Podemos añadir el audio de nuestro micrófono real y nuestras aplicaiones mediante el script \texttt{pipewire-virtualmic-select}.

\section{Cronie y scripts útiles}

El repositorio incluye una variedad de scripts para automatizar tareas. Por defecto no se usan, pero podemos hacer que se ejecuten de forma automática con \href{https://wiki.archlinux.org/title/cron}{crond}.

\subsection{convert-2m4a y convert-2mp3}

Estos scripts convierten toda la música del directorio que damos como primer argumento a formato \textit{.m4a} o \textit{.mp3} en un mirror que replica al estructura de los archivos en el directorio original.

\medskip
\noindent Si ejecutamos:
\begin{verbatim}
convert-2mp3 /musica/biblioteca /musica/mp3
\end{verbatim}
Toda la música de \path{/musica/biblioteca} se convertira en mp3 en la carpeta \path{/musica/mp3}
\begin{itemize}
\item El script puede usarse con el flag \textit{-p} para convertir varios archivos de forma paralela, lo que reduce el tiempo necesario para la conversión de archivos, pero consume más recursos y probablemente ocupe todo el tiempo de CPU hasta que el script se termine de ejecutar.
\item El script también puede usarse con el flag \textit{-l} lo que hará que además de convertir las canciones a otro formato, se busque la letra de la canción y se incluya dentro del archivo de audio.
\end{itemize}

\subsection{corruption-check}

Este script comprueba que no haya archivos corruptos en nuestra biblioteca de música, corrige falsos positivos de corrupción y nos escribe una lista con los archivos que no se pueden reproducir correctamente en \path{/tmp/corruption.log}. Necesita como argumento el directorio cuyos archivos de audio queremos analizar.

\subsection{exif-remove}

Este script necesita borra toda la información \href{https://en.wikipedia.org/wiki/Exif}{EXIF} de las imágenes que contiene el directorio que se le da como argumento.

\subsection{wake}

Este script comprueba si hay alguna máquina virtual en ejecución, y si no encuentra ninguna, suspende nuestro equipo y lo reanuda a las 7 de la mañana del día siguiente. Útil para ahorrar energía y no tener que preocuparte por suspender tu equipo, ni de encenderlo por las mañanas.

\medskip
El script te avisa de que el sistema se va suspender y pasados 10 minutos desde dicho aviso, suspende el sistema. \emph{Si el script se ejecuta pasándole el argumento ``now'', entonces el sistema se supenderá inmediatamente}.

\subsection{wakeme}

Este script funciona como un despertador, hace sonar el archivo de audio especificado hasta que le damos al un botón que apaga nuestra alarma.

\subsection{compressed-backup}

Este script crea un fichero comprimido \texttt{tar.gz} con una copia de seguridad del directorio que se le da por primer argumento en el directorio que se le da por segundo argumento. Además se encarga de borrar las copias de seguridad que tienen mas de un mes automáticamente.

\section{VFIO GPU passthrough}

Con VFIO (Virtual Function I/O) GPU passthrough podemos pasarle una tarjeta gráfica física a una máquina virtual. Lo que nos permite tener gráficos acelerados dentro de dicha máquina virtual.

\subsection{Pasos Iniciales}

\begin{itemize}
\setlength\itemsep{-0.2em}
\item Primero activamos \href{https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-d}{VT-d} o \href{https://en.wikipedia.org/wiki/X86_virtualization#AMD_virtualization_(AMD-V)}{AMD-v} \emph{dependiendo de si tenemos un procesador Intel o AMD}.
\item Debemos de tener \href{https://en.wikipedia.org/wiki/Input\%E2\%80\%93output_memory_management_unit}{IOMMU} activado. En la mayoría de placas bases activar VT-d o AMD-v, también activa IOMMU.
\item Debemos tener desactivado \href{https://en.wikipedia.org/wiki/UEFI#CSM_booting}{CSM (Compatibility Support Module)} en los ajustes de arranque de nuestra placa base.
\end{itemize}

\subsection{Pre-configurar el gestor de arranque}

El gestor de arranque \href{https://es.wikipedia.org/wiki/GNU_GRUB}{GNU GRUB}, es el programa que se encarga de cargar el kernel de nuestro sistema operativo.

\medskip
Para usar VFIO necesitamos configurar el arranque del kernel. Las opciones de configuración globales de GRUB están en \path{/etc/default/grub}

\medskip
Este archivo contiene las opciones de arranque del kernel en: \textit{GRUB\_CMDLINE\_LINUX}.

\begin{verbatim}
GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet"
GRUB_CMDLINE_LINUX=""
\end{verbatim}

Tendremos que añadir las siguientes opciones:
\begin{itemize}
\setlength\itemsep{-0.2em}
\item \path{iommu=pt}
\item \path{amd_iommu=on} o \path{intel_iommu=on}, dependiendo de si tenemos una cpu Intel o AMD.
\item \path{video=efifb:off}
\end{itemize}

\begin{verbatim}
GRUB_CMDLINE_LINUX="intel_iommu=on iommu=pt video=efifb:off"
GRUB_CMDLINE_LINUX="amd_iommu=on iommu=pt video=efifb:off"
\end{verbatim}

Una vez editado el archivo, debemos actualizar nuestra configuración de GRUB con:

\begin{verbatim}
# grub-mkconfig -o /boot/grub/grub.cfg
\end{verbatim}

\subsection{Identificar el ID de nuestra gráfica y los grupos IOMMU}

Después de esto ya podemos asignar el driver VFIO a nuestra tarjeta gráfica para poder usarla en nuestra máquina virtual.

\vspace{5pt}

Necesitamos conocer el identificador de nuestra gráfica, podemos obtener esta informaciónejecutando en BASH:

\begin{verbatim}
shopt -s nullglob
for g in /sys/kernel/iommu_groups/*; do
    echo "IOMMU Group ${g##*/}:"
    for d in $g/devices/*; do
        echo -e "\t$(lspci -nns ${d##*/})"
    done;
done;
\end{verbatim}

\begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
IOMMU Group 15:
  08:00.0 VGA compatible controller [0300]: NVIDIA TU116 [GeForce GTX 1660] [10de:21c4] (rev a1)
  08:00.1 Audio device [0403]: NVIDIA TU116 High Definition Audio Controller [10de:1aeb] (rev a1)
  08:00.2 USB controller [0c03]: NVIDIA Device [10de:1aec] (rev a1)
  08:00.3 Serial bus controller [0c80]: NVIDIA TU116 [GeForce GTX 1650] [10de:1aed] (rev a1)
\end{lstlisting}
Debemos añadir cada uno de los IDs de los dispositivos que se encuentran en el mismo grupo que nuestra gráfica (en nuestro ejemplo: \texttt{10de:21c4}, \texttt{10de:1aeb}, \texttt{10de:1aec} y \texttt{10de:1aed}) a nuestro archivo de configuración de GRUB, diciéndole que le asigne a estos dispositivos el driver vfio.

\begin{verbatim}
GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet"
GRUB_CMDLINE_LINUX="amd_iommu=on iommu=pt video=efifb:off
vfio-pci.ids=10de:21c4,10de:1aeb,10de:1aec,10de:1aed"
\end{verbatim}

Ejecutamos de nuevo:
\begin{verbatim}
# grub-mkconfig -o /boot/grub/grub.cfg
\end{verbatim}

\subsection{Módulos del kernel}

Ahora cada vez que iniciemos nuestro ordenador el kernel intentará asignarle a esos dispositivos PCI el driver VFIO, pero el driver VFIO por defecto no se carga durante el arranque del sistema.

\medskip
Debemos de configurar nuestro kernel para que nuestra imagen de arranque incluya el driver VFIO, para poder asignarselo a nuestra gráfica.

\medskip
Para esto debemos editar \path{/etc/mkinitcpio.conf} y añadir los módulos del kernel que vamos a usar.

\begin{verbatim}
MODULES=( vfio_pci vfio vfio_iommu_type1 )
\end{verbatim}

Una vez editado nuestro archivo debemos regenerar el \href{https://en.wikipedia.org/wiki/Initial\_ramdisk}{initramfs} con:
\begin{verbatim}
# mkinitcpio -P
\end{verbatim}

Para comprobar que hemos seguido los pasos correctamente reiniciamos nuestro ordenador y cuando arranque de nuevo, ejecutamos:
\begin{verbatim}
# dmesg | grep -i vfio
\end{verbatim}

Si tenemos una salida parecida a:
\begin{lstlisting}[basicstyle=\small\ttfamily]
[3.416692] vfio_pci: add [10de:21c4[ffffffff:ffffffff]] class 0x000000/00000000
[3.433353] vfio_pci: add [10de:1aeb[ffffffff:ffffffff]] class 0x000000/00000000
[3.450019] vfio_pci: add [10de:1aec[ffffffff:ffffffff]] class 0x000000/00000000
[3.466953] vfio_pci: add [10de:1aed[ffffffff:ffffffff]] class 0x000000/00000000
\end{lstlisting}
donde podemos ver que el driver \path{vfio_pci} se ha cargado correctamente para nuestros dispositivos, entonces hemos realizado correctamente todos los pasos.

\subsection{Instalación del sistema operativo}

Ya tenemos lista nuestra gráfica para ser usada por nuestra máquina virtual, queda instalar nuestra máquina virtual y configurarla para usarla cómodamente.

\medskip
Descargamos la ISO de Windows 10 desde \href{https://www.microsoft.com/en-us/software-download/windows10ISO}{https://www.microsoft.com}, y los drivers que necesitará Windows desde \href{https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso}{https://fedorapeople.org}.

\medskip
Una vez descargadas las ISO, abrimos \textit{virt-manager} y creamos una máquina virtual:

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{images/vm-iso-selection.png}
	\end{minipage}
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{images/vm-disk-creation.png}
	\end{minipage}
\end{figure}

Asignamos la memoria RAM \textit{(8GB como mínimo)} a nuestra máquina virtual. Y en el último paso, elegimos \textit{customizar nuestra máquina virtual} antes de la instalación.

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{images/vm-memory-setup.png}
	\end{minipage}
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{images/vm-name.png}
	\end{minipage}
\end{figure}

Ahora deberás hacer las siguientes modificaciones:

\begin{itemize}
\setlength\itemsep{-0.3em}
\item Cambiar el chipset a \textit{Q35}
\item Elegir el firmware \path{UEFI: x86_64: /usr/share/edk2/x64/OVMF_CODE.fd}
\item En la pestaña \textit{CPUs} activa el recuadro \textit{Copiar configuración de la CPU del anfitrión}, despliega el menú \textit{Topología} y ajusta la topología de la forma siguiente:
\vspace{-20pt}
\begin{itemize}
	\item 1 \textit{Socket}, Tantos \textit{Centros} comos núcleos tenga tu procesador y tantos \textit{Hilos} como hilos tenga tu procesador por núcleo. Por ejemplo para un procesador con 8 núcleos y 16 hilos, elegiríamos: \textit{1 Socket, 8 Centros, 2 Hilos}. Esto es, si queremos asignar todos los núcleos a nuestra máquina virtual.
\end{itemize}
\item Nos dirigimos a \textit{SATA Disk 1} y cambiamos el bus a VirtIO, de forma que ahora aparezca \textit{VirtIO Disk 1}. Abrimos las opciones avanzadas, y cambiamos el modo de caché a \textit{writeback}.
\item En los ajustes del \textit{NIC} cambiamos el modelo de dispositivo a \textit{virtio}
\item Por último dale a \textit{Añadir hardware} y añade un almacenamiento de tipo de dispositivo CDROM y escribe al lado de \textit{Administrar...} la localización de el ISO con los drivers virtio, por ejemplo: \textit{/home/usuario/Downloads/virtio-win.iso}.
\end{itemize}

\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{0.4965\textwidth}
		\includegraphics[width=\textwidth]{images/windows-setup-01.png}
	\end{minipage}
	\begin{minipage}[b]{0.4965\textwidth}
		\includegraphics[width=\textwidth]{images/windows-setup-02.png}
	\end{minipage}
\end{figure}

Dale a \textit{Iniciar la instalación} y cuando veas la selección de disco del instalador de windows verás que está vacío. Primero debes darle a \textit{Cargar driver} o \textit{Load driver}, en inglés.

\vspace{5pt}

Selecciona el CD con los drivers virtio y la carpeta que contiene los drivers para Windows 10. Entonces aparecerá tu disco duro virtual y podrás continuar la instalación de Windows. Cuando esta finalize, apaga la máquina virtual.

\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{0.4965\textwidth}
		\includegraphics[width=\textwidth]{images/windows-setup-03.png}
	\end{minipage}
	\begin{minipage}[b]{0.4965\textwidth}
		\includegraphics[width=\textwidth]{images/windows-setup-04.png}
	\end{minipage}
\end{figure}

\subsection{Looking Glass en el Host}

Para poder usar nuestra máquina virtual de forma cómoda vamos a configurar \href{https://looking-glass.io/}{Looking Glass}. Una aplicación que nos permite ver la pantalla conectada a nuestra gráfica a través de una ventana y poder controlar nuestra máquina virtual sin necesidad de conectar un teclado y ratón sólo para nuestra máquina virtual. El único problema es que para usar looking glass sin necesidad de dos monitores, necesitamos comprar un \href{https://www.amazon.com/s?k=display+dummy}{display dummy}. Por lo menos, su precio suele rondar los 5-7€.

\vspace{5pt}

Looking Glass nos muestra una imagen de lo que esta haciendo nuestra gráfica con una latencia muy baja, suficiente para poder jugar a juegos o editar vídeo \textit{(y otros usos posibles)} sin problema en nuestra máquina virtual. Logra esto mandando la información a través de un archivo compartido entre máquina virtual y host.

Primero necesitamos configurar \href{dsada}{tmpfilesd} para que cada vez que iniciamos el sistema, cree el archivo que compartirán máquina virtual y host para enviarse información. Tenemos que ejecutar el siguiente comando \textit{(sustituyendo usuario por el nombre de tu usuario)}:

\begin{verbatim}
echo "f /dev/shm/looking-glass 0660 usuario kvm -" | \
doas tee -a /etc/tmpfiles.d/looking-glass.conf
\end{verbatim}

Tenemos que instalar el servicio que se encarga de crear estos archivos con:

\begin{verbatim}
doas pacman -Sy --noconfirm etmpfiles
\end{verbatim}

\subsection{Añadir Gráfica y Looking Glass en el Guest}

Ahora ya tenemos casi todo listo, queda instalar los drivers de vídeo e instalar Looking Glass en nuestra máquina virtual \textit{(a la hora de la instalación debió de haberse instalado ya en nuestro linux)}.

\vspace{5pt}

Primero tenemos que añadir nuestra tarjeta gráfica a nuestra máquina virtual. Para ello tenemos que ir a los ajustes de nuestra máquina virtual y en \textit{``Añadir Dispositivo"}, busca la pestaña para añadir dispositivos PCI y añade tu gráfica.

\vspace{5pt}

Después debemos de configurar el servidor Spice para que use el puerto 6000 en vez de asignar un puerto automáticamente

\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{0.4965\textwidth}
		\includegraphics[height=0.6\textwidth,width=\textwidth]{images/card-add.jpg}
	\end{minipage}
	\begin{minipage}[b]{0.4965\textwidth}
		\includegraphics[height=0.6\textwidth,width=\textwidth]{images/spice-conf.jpg}
	\end{minipage}
\end{figure}

Ahora tenemos que activar la edición de XML en Virt-Manager (Editar $\to$ Preferencias) y editar el código XML de nuestra máquina virtual. Añadiremos estas lineas de código al final para que el archivo acabe viéndose así:

\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{0.3285\textwidth}
		\includegraphics[height=0.6\textwidth,width=\textwidth]{images/xml-enable.jpg}
	\end{minipage}
	\begin{minipage}[b]{0.3285\textwidth}
		\includegraphics[height=0.6\textwidth,width=\textwidth]{images/xml-edit.jpg}
	\end{minipage}
	\begin{minipage}[b]{0.3285\textwidth}
		\includegraphics[height=0.6\textwidth,width=\textwidth]{images/video-none.jpg}
	\end{minipage}
\end{figure}

Iniciamos nuestra máquina virtual e instalamos nuestros drivers de \href{https://www.nvidia.es/Download/index.aspx?lang=es}{NVIDIA} o \href{https://www.amd.com/es/support}{AMD} y \href{https://looking-glass.io/downloads}{Looking Glass Host}.

\vspace{5pt}

Finalmente cambiamos el driver virtual de video de \textit{QXL} a \textit{None} y borramos el dispositivo de tableta táctil. La próxima vez que iniciemos la máquina virtual solo tenemos que iniciarla en Virt-Manager e ínteractuaremos con nuestra máquina virtual abriendo Looking Glass \textit{(Podemos abrirlo seleccionando ``Looking Glass`` en el menú que aparece cuando hacemos clic derecho en alguna parte vacía del Escritorio)}.

\clearpage

\noindent Para que esto funcione debemos reiniciar nuestro ordenador o ejecutar el comando.

\begin{verbatim}
doas install -g kvm -o $(whoami) -m 0660 /dev/null /dev/shm/looking-glass
\end{verbatim}

\begin{mybox}{Nota}

Para más información sobre como configurar un VFIO passthought puede consultar:

\vspace{-7.5pt}

\begin{itemize}
\setlength\itemsep{-0.3em}
\item \href{https://qqq.ninja/blog/post/vfio-on-arch/}
{https://qqq.ninja/blog/post/vfio-on-arch/}
\item \href{https://gitlab.com/risingprismtv/single-gpu-passthrough/-/wikis/home}
{https://gitlab.com/risingprismtv/single-gpu-passthrough/-/wikis/home}
\item \href{https://wiki.archlinux.org/title/PCI\_passthrough\_via\_OVMF}
{https://wiki.archlinux.org/title/PCI\_passthrough\_via\_OVMF}
\end{itemize}
\end{mybox}

\section{VirtioFS}

Podemos usar virtiofs para compartir directorios del host con nuestra máquina virtual. Para ello, necesitamos añadir los directorios deseados desde Virt-Manager, seleccionando: Añadir hardware, Sistema de archivos, eligiendo la Ruta de origen (la carpeta que queremos compartir) y la Ruta objetivo (el nombre con el que aparecerá en nuestra máquina invitada).

\vspace{5pt}

También necesitamos instalar los controladores de VirtIO en el host. Si todavía tenemos montado el disco que contiene estos controladores, encontraremos en el CD un instalador (virtio-win-gt-x64.msi) para los controladores, así como otro instalador \emph{opcional} para añadir la integración con el host (virtio-win-guest-tools.exe), que permite funciones como compartir el portapapeles, entre otras.

\vspace{5pt}

Después de instalar los controladores, debemos instalar \href{https://github.com/winfsp/winfsp}{WinFSP} para poder montar sistemas de archivos VirtioFS. Y seguidamente ejecutar en el cmd de windows:

\begin{verbatim}
"C:\Program Files (x86)\WinFsp\bin\fsreg.bat" virtiofs \
"C:\Program Files\Virtio-Win\VioFS\virtiofs.exe" "-t %1 -m %2"
\end{verbatim}

\vspace{5pt}

Una vez que tenemos todo instalado, podemos crear un script `.bat` que monte nuestras carpetas en la máquina invitada. Por ejemplo, si tenemos dos carpetas cuyas rutas objetivo son ``documentos'' y ``videos'', y queremos montarlas en ``Y:'' y ``Z:'', respectivamente, podemos crear un script para montar ambas de la siguiente manera:

\vspace{5pt}

\begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
"C:\Program Files (x86)\WinFsp\bin\launchctl-x64.exe" start virtiofs documentos documentos Y:
"C:\Program Files (x86)\WinFsp\bin\launchctl-x64.exe" start virtiofs videos videos Z:
\end{lstlisting}

\section{Conexión bridge y RDP}

Adicionalmente, podemos configurar nuestra máquina virtual para, a efectos prácticos, comportarse como un ordenador distinto en la red. En vez de usar un NAT y que nuestro host se encargue del re-direccionamiento al guest, podemos usar una conexión puente y hacer que nuestro router reconozca nuestra máquina virtual como un dipositivo distinto y le asigne su propia IP. Esto es útil para abrir servicios desde nuestro guest y poder alcanzarlos desde el exterior de nuestra red privada.

\subsection{Creación de nuestra red puente}

Para crear nuestra conexión de puente, utilizaremos \emph{NetworkManager}. Podemos configurar nuestras conexiones a través de la terminal usando \texttt{nmtui}. Al ejecutar \texttt{nmtui}, seleccionaremos \emph{Modificar una conexión} y luego \emph{<Añadir>}. En el tipo de red, escogeremos \emph{Puente}.

Una vez que seleccionemos el dispositivo tipo \emph{Puente}, aparecerán las distintas opciones de configuración de nuestra red. Procederemos a configurar el dispositivo que queremos puentear; para ello, en la sección \emph{Puente, ports}, seleccionamos \emph{<Añadir>} y elegimos \emph{<Ethernet>} (Nota: esto solo funciona correctamente para dispositivos conectados mediante Ethernet; no es posible utilizar conexiones puenteadas a través de Wi-Fi). Luego, seleccionamos \emph{<Crear>} y finalmente \emph{<Aceptar>}. Por último, confirmaremos los cambios para agregar nuestra conexión de puente.

Finalmente, debemos eliminar la conexión Ethernet de la lista de conexiones en \emph{NetworkManager} (no te preocupes, tu host seguirá teniendo acceso a internet; tanto la máquina anfitriona como la máquina invitada usarán la conexión de puente para acceder a internet). Para ello, en \texttt{nmtui} seleccionamos \emph{Modificar una conexión} y eliminamos la conexión correspondiente.

\subsection{Invitado con conexión puenteada}

Ahora tenemos que decirle a virt-manager que queremos usar nuestra conexión puenteada para la máquina virtual, podemos incluso borrar la red NAT \emph{`default"} si no tenemos ninguna otra máquina virtual que queramos conectar a internet.

Para usar la conexión puenteada en nuestra máquina virtual; en las propiedades de nuestra máquina virtual, dentro de la configuración del \textbf{NIC} vamos a elegir en la \emph{`Fuente de red"} nuestra conexión puenteada.

Adicionalmente, podemos ajustar la dirección MAC y establecer una IP estática asociada a esa dirección MAC en nuestro router. Lo cual facilitará confiurar servicios y acceder a nuestra máquina invitada desde la red.

\subsection{Configurar Escritorio remoto}

Ahora podemos configurar nuestra máquina invitada para acceder remotamente a ella mediante RDP, para ello en Windows \emph{(Sólo si tenemos Windows 10/11 Pro)} en Ajustes/Escritorio Remoto, activaremos el escritorio remoto.

Es recomendable configurar el firewall de nuestro guest para permitir las conexiones entrantes de RDP y ICMP, para ello ejecutaremos estos comandos en la Consola de Comandos como Administrador:

\begin{lstlisting}[basicstyle=\tiny\ttfamily]
netsh advfirewall firewall add rule name="Allow ICMPv4-In" protocol=icmpv4:any,any dir=in action=allow
netsh advfirewall firewall add rule name="Allow ICMPv6-In" protocol=icmpv6:any,any dir=in action=allow
netsh advfirewall firewall add rule name="Allow RDP" protocol=TCP dir=in localport=3389 action=allow
\end{lstlisting}

Podemos conectarnos ya a nuestra máquina usando freerdp con el comando

\begin{lstlisting}[basicstyle=\small\ttfamily]
xfreerdp3 /u:USUARIO /p:'CONTRASEÑA' /v:IP /auth-pkg-list:'!kerberos' \
	/sound:sys:alsa /size:1920x1080 /smart-sizing:1920x1080 +clipboard
\end{lstlisting}

O puedes usar el script \texttt{rdp-connect}

\section{SSH}

Si queremos conectarnos a un equipo remoto a través de internet debemos configurar \href{https://es.wikipedia.org/wiki/OpenSSH}{OpenSSH}. Por defecto incluyo un script que configura SSH de forma muy básica, configurando SSH para poder acceder a tu equipo remoto con una contraseña. Para activar SSH simplemente ejecuta:

\begin{verbatim}
ssh-configure
\end{verbatim}

Mi recomendación es no conformarse con esta configuración básica. Desactiva el login con el usuario root, desactiva el login por contraseña y usa claves públicas para conectarte. Si no sabes de lo que estoy hablando, es mejor que no uses SSH y no te expongas a abrir la puerta a tu ordenador al internet, aunque sea con candado.

\subsection{VNC através de SSH}

Podemos usar SSH para acceder a nuestro entorno gráfico de forma remota y usar nuestro ordenador sin estar necesariamente delante de el físicamente. Por defecto dwm inicia un servidor \href{https://en.wikipedia.org/wiki/Virtual_Network_Computing}{VNC} para que puedas conectarte remotamente a una interfaz gráfica. Para poder hacer uso del servidor VNC tienes que usar \href{https://en.wikipedia.org/wiki/Tunneling_protocol}{tunneling}. Para conectarte y poder usar VNC, ejecuta:

\begin{verbatim}
ssh usuario@255.255.255.255 -L 5900:localhost:5900
\end{verbatim}

Sustituye \textit{usuario} por el usuario de tu máquina, y \textit{255.255.255.255} por la dirección IP de tu máquina. Para conectarte al equipo remotamente debes tener instalado algún cliente VNC, mi recomendación es \href{https://github.com/FreeRDP/Remmina}{remmina}.

\section{Firewall}

Instalar y configurar un firewall no es posible dentro de un chroot. Por eso configurar el firewall debe hacerse una vez reiniciemos y hallamos arrancado nuestro sistema operativo. Para instalar el firewall ejecuta:

\begin{verbatim}
doas sh -c 'pacman -Sy ufw-openrc; rc-update add ufw default; ufw enable'
\end{verbatim}

Ahora, la próxima vez que inicies tu equipo tendras un firewall ya instalado. Para configurarlo puedes ejecutar los siguientes comandos, que establecen unas reglas de filtrado de paquetes bastante permisivas.

\begin{verbatim}
doas ufw limit 22/tcp; doas ufw allow 80/tcp
doas ufw allow 443/tcp; doas ufw allow syncthing
doas ufw default deny incoming; doas ufw default allow outgoing
\end{verbatim}

\begin{mybox}{Nota}
Si ejecutaste \textit{ssh-configure} el firewall ya se configuró automaticamente
\end{mybox}

\section{Syncthing}

\href{https://github.com/syncthing/syncthing}{Syncthing} es un software para sincronizar archivos entre dispositivos, es lo que uso para poder trabajar en todos mis equipos sin necesidad de estar intercambiando pen-drives como un troglodita.

Viene instalado por defecto y se ejecuta cuando inicias tu ordenador. Para configurarlo tiene una \href{http://localhost:8384/}{interfaz gráfica} a la que puedes acceder desde tu navegador.

\begin{mybox}{Información}
Aquí puedes encontrar documentación sobre como usar syncthing: \href{https://docs.syncthing.net/}{https://docs.syncthing.net/}
\end{mybox}

\section{Monitores de altas tasas de refresco}

Por defecto dwm actualiza el movimiento de las ventanas a 60 FPS. Si tienes un monitor de mas de 60 Hz esto puede hacer la experiencia de usar dwm insatisfactoria. Para cambiar este comportamiento, debes editar el archivo \textit{dwm.c}. En el encontrarás varias funciones con esta misma linea de código:

\begin{verbatim}
if ((ev.xmotion.time - lasttime) <= (1000 / 60))
\end{verbatim}

Deberás cambiar el valor \textit{60} por la tasa de refresco de tu monitor en cada aparición de esta linea. Por ejemplo, para un monitor de \textit{144 Hz}, la líneas a cambiar deberían verse así: \path{if ((ev.xmotion.time - lasttime) <= (1000 / 144))}

\section{Firefox}

\subsection{Cambiar buscador por defecto}

\vspace{-15pt}

\begin{figure}[h!]
	\fcapside[\FBwidth]{\caption*{Pese a usar \href{https://github.com/arkenfox/user.js}{arkenfox} para mejorar algunos ajustes relacionados con la privacidad, el buscador por defecto sigue siendo Google. Es recomendable cambiarlo por alguno como \href{https://search.brave.com/}{Brave Search} o \href{https://duckduckgo.com/}{DuckDuckGo}.}}
{\includegraphics[width=0.5\textwidth,height=0.175\textwidth]{images/search-engine.jpg}}
\end{figure}%

\vspace{-20pt}

\subsection{Violentmonkey}

Violentmonkey es una extensión para cargar pequeños scripts de javascript justop después de cargar la página web, para automatizar ciertas tareas o añadir funcionalidades. Si vas a los ajustes de la extensión, verás que hay una pestaña donde puedes importar tus ajustes. Podemos importar nuestros ajustes que están en el archivo:

\begin{figure}[h!]
	\captionsetup{labelformat=empty}
	\centering
	\includegraphics[width=0.6\textwidth]{images/violentmonkey.jpg}
	\cprotect\caption{\verb|~/.dotfiles/assets/violentmonkey.zip|}
\end{figure}

\vspace{-20pt}

\subsection{Añadir buscadores útiles}

Aquí tienes una lista de buscadores útiles, para añadirlos a tu buscador simplemente accede a cada página haciendo doble clic, y cuando estés en ella haz clic derecho en la barra de navegación y selecciona \textit{Añadir "Buscador"}.

\begin{multicols}{5}
\scriptsize
\begin{itemize}
\setlength\itemindent{-0.75em}
\setlength\itemsep{-0.35em}
\item \href{https://wiki.archlinux.org/}{Arch Wiki}
\item \href{https://wiki.gentoo.org/wiki/Main_Page}{Gentoo Wiki}
\item \href{https://wiki.alpinelinux.org/wiki/Main_Page}{Alpine Wiki}
\item \href{https://www.youtube.com/}{YouTube}
\item \href{https://nyc1.pi.ggtyler.dev/trending}{Piped}
\item \href{https://iv.ggtyler.dev/feed/popular}{Invidious}
\item \href{https://github.com/}{GitHub}
\item \href{https://yandex.com/}{Yandex}
\item \href{https://nyaa.si/}{Nyaa}
\item \href{https://stackoverflow.com/}{Stack Overflow}
\end{itemize}
\end{multicols}

Las Wikis de Gentoo y Alpine nos resultarán de utilidad, pues ambas distribuciones utilizan OpenRC en vez de SystemD. De hecho, si no encuentras un script de OpenRC para algún servicio en los repositorios de Artix, puedes copiar el script que utilizan Alpine o Gentoo.

\section{Miscelánea}

\subsection*{Configuraciones locales}

Nuestra configuración de \texttt{zsh} tiene varios \emph{alias} configurados en:

\begin{center}
\path{~/.config/zsh/aliasrc}
\end{center}

Si deseamos añadir alias de forma no global, sin tener que añadir archivos al repositorio y de manera exclusiva para nuestro equipo, podemos crear un archivo con más funciones y abreviaciones en:

\begin{center}
\path{~/.config/useralias}
\end{center}

\subsection*{Aviso de Uso}

Este proyecto es para uso personal. Se comparte con la intención de que pueda ser útil para otros, pero se proporciona tal cual, sin ninguna garantía. No se asume responsabilidad por ninguna pérdida de datos o problemas que puedan surgir del uso de este proyecto.

\vspace{5pt}

No obstante, se aceptan propuestas de mejora razonables. Si alguien desea contribuir a hacer este setup más extensible y robusto, puede realizar un merge request sin inconveniente.

\end{document}
